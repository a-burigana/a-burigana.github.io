<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>Papers | Alessandro Burigana</title>
<meta name="keywords" content="">
<meta name="description" content="Preprints and articles by Alessandro Burigana.">
<meta name="author" content="Alessandro Burigana">
<link rel="canonical" href="http://localhost:1313/papers/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.e690afcd5c523330d5c8b4d746eb158361600a015e99518d4d246a6ccab0cc19.css" integrity="sha256-5pCvzVxSMzDVyLTXRusVg2FgCgFemVGNTSRqbMqwzBk=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="http://localhost:1313/papers/index.xml">
<link rel="alternate" hreflang="en" href="http://localhost:1313/papers/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:title" content="Papers" />
<meta property="og:description" content="Preprints and articles by Alessandro Burigana." />
<meta property="og:type" content="website" />
<meta property="og:url" content="http://localhost:1313/papers/" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Papers"/>
<meta name="twitter:description" content="Preprints and articles by Alessandro Burigana."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Papers",
      "item": "http://localhost:1313/papers/"
    }
  ]
}
</script>



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css" integrity="sha384-wcIxkf4k558AjM3Yz3BBFQUbk/zgIYC2R0QpeeYb+TwlBVMrlgLqwRjRtGZiK7ww" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js" integrity="sha384-hIoBPJpTUs74ddyc4bFZSM1TVlQDA60VBbJS0oA934VSz82sBx1X7kSx2ATBDIyd" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/contrib/auto-render.min.js" integrity="sha384-43gviWU0YVjaDtb/GhzOouOXtZMP/7XUzwPTstBeZFe/+rCMvRwr4yROQP43s0Xk" crossorigin="anonymous"
  onload="renderMathInElement(document.body);"></script>

<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
          delimiters: [
            {left: '$$', right: '$$', display: true},
            {left: '$', right: '$', display: false},
            {left: "\\begin{equation}", right: "\\end{equation}", display: true},
            {left: "\\begin{equation*}", right: "\\end{equation*}", display: true},
            {left: "\\begin{align}", right: "\\end{align}", display: true},
            {left: "\\begin{align*}", right: "\\end{align*}", display: true},
            {left: "\\begin{alignat}", right: "\\end{alignat}", display: true},
            {left: "\\begin{gather}", right: "\\end{gather}", display: true},
            {left: "\\begin{CD}", right: "\\end{CD}", display: true},
          ],
          throwOnError : false
        });
    });
</script>
 


</head>

<body class="list" id="top">

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Alessandro Burigana">
                <img src="http://localhost:1313/favicon.ico" alt="" aria-label="logo"
                    height="18"
                    width="18">Alessandro Burigana</a>
            <div class="logo-switches">
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/papers/" title="Papers">
                    <span class="active">Papers</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/projects/" title="Projects">
                    <span>Projects</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/dissemination/" title="Dissemination">
                    <span>Dissemination</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/archive/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>

    <main class="main"> 
<header class="page-header">
  <h1>
  </h1>
</header>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Glocal Conformance Checking
    </h2>
  </header>
  <div class="entry-content">
    <p>Conformance checking is a process mining task where observed process executions are compared with the conduct prescribed by a process model. Even in the case where multiple parties interact in the process, it is typically assumed that the process itself provides a monolithic, global description of the overall, expected behaviour. However, it may very well be the case that such a global process is not explicitly available, and that each agent comes with its own local view of the process, while the overall behaviour is only be implicitly obtained by composing such local views. In this paper, we provide for the first time a formal framework for glocal conformance checking, where a global observed trace of a multi-party process is related to local Data Petri nets, each representing the subjective view of each participating agent. We formulate conformance checking in this multi-agent setting as an alignment problem, and show how it can be tackled by “acting locally, and thinking globally”, that is, pairing local alignments with a suitable global compatibility condition. We then observe that in this setting, cost functions must take the context of activities in the global trace into account, which is realised through a new schema of regular expression-based cost functions. We pair the foundational investigation of the problem with a proof-of-concept SMT-based implementation.</p>
  </div>
  <footer class="entry-footer"><span title='2024-09-02 00:00:00 +0000 UTC'>September 2024</span>&nbsp;&middot;&nbsp;Alessandro Burigana,&thinsp;Alessandro Gianola,&thinsp;Marco Montali,&thinsp;Sarah Winkler</footer>
  <a class="entry-link" aria-label="post link to Glocal Conformance Checking" href="http://localhost:1313/papers/2024-09-02-bpm/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Better Bounded Bisimulation Contractions
    </h2>
  </header>
  <div class="entry-content">
    <p>Bisimulations are standard in modal logic and, more generally, in the theory of state-transition systems. The quotient structure of a Kripke model with respect to the bisimulation relation is called a bisimulation contraction. The bisimulation contraction is a minimal model bisimilar to the original model, and hence, for (image-)finite models, a minimal model modally equivalent to the original. Similar definitions exist for bounded bisimulations ($k$-bisimulations) and bounded bisimulation contractions. Two finite models are $k$-bisimilar if and only if they are modally equivalent up to modal depth $k$. However, the quotient structure with respect to the $k$-bisimulation relation does not guarantee a minimal model preserving modal equivalence to depth $k$. In this paper, we remedy this asymmetry to standard bisimulations and provide a novel definition of bounded contractions called rooted $k$-contractions. We prove that rooted $k$-contractions preserve $k$-bisimilarity and are minimal with this property. Finally, we show that rooted $k$-contractions can be exponentially more succinct than standard $k$-contractions.</p>
  </div>
  <footer class="entry-footer"><span title='2024-08-01 00:00:00 +0000 UTC'>August 2024</span>&nbsp;&middot;&nbsp;Thomas Bolander,&thinsp;Alessandro Burigana</footer>
  <a class="entry-link" aria-label="post link to Better Bounded Bisimulation Contractions" href="http://localhost:1313/papers/2024-08-01-aiml/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">A Semantic Approach to Decidability in Epistemic Planning
    </h2>
  </header>
  <div class="entry-content">
    <p>The use of Dynamic Epistemic Logic (DEL) in multi-agent planning has led to a widely adopted action formalism that can handle nondeterminism, partial observability and arbitrary knowledge nesting. As such expressive power comes at the cost of undecidability, several decidable fragments have been isolated, mainly based on syntactic restrictions of the action formalism. In this paper, we pursue a novel semantic approach to achieve decidability. Namely, rather than imposing syntactical constraints, the semantic approach focuses on the axioms of the logic for epistemic planning. Specifically, we augment the logic of knowledge S5$_n$ and with an interaction axiom called (knowledge) commutativity, which controls the ability of agents to unboundedly reason on the knowledge of other agents. We then provide a threefold contribution. First, we show that the resulting epistemic planning problem is decidable. In doing so, we prove that our framework admits a finitary non-fixpoint characterization of common knowledge, which is of independent interest. Second, we study different generalizations of the commutativity axiom, with the goal of obtaining decidability for more expressive fragments of DEL. Finally, we show that two well-known epistemic planning systems based on action templates, when interpreted under the setting of knowledge, conform to the commutativity axiom, hence proving their decidability.</p>
  </div>
  <footer class="entry-footer"><span title='2023-10-18 00:00:00 +0000 UTC'>October 2023</span>&nbsp;&middot;&nbsp;Alessandro Burigana,&thinsp;Paolo Felli,&thinsp;Marco Montali,&thinsp;Nicolas Troquard</footer>
  <a class="entry-link" aria-label="post link to A Semantic Approach to Decidability in Epistemic Planning" href="http://localhost:1313/papers/2023-10-18-ecai/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">DELPHIC: Practical DEL Planning via Possibilities
    </h2>
  </header>
  <div class="entry-content">
    <p>Dynamic Epistemic Logic (DEL) provides a framework for epistemic planning that is capable of representing non-deterministic actions, partial observability, higher-order knowledge and both factual and epistemic change. The high expressivity of DEL challenges existing epistemic planners, which typically can handle only restricted fragments of the whole framework. The goal of this work is to push the envelop of practical DEL planning, ultimately aiming for epistemic planners to be able to deal with the full range of features offered by DEL. Towards this goal, we question the traditional semantics of DEL, defined in terms on Kripke models. In particular, we propose an equivalent semantics defined using, as main building block, so-called possibilities: non well-founded objects representing both factual properties of the world, and what agents consider to be possible. We call the resulting framework DELPHIC. We argue that DELPHIC indeed provides a more compact representation of epistemic states. To substantiate this claim, we implement both approaches in ASP and we set up an experimental evaluation to compare DELPHIC with the traditional, Kripke-based approach. The evaluation confirms that DELPHIC outperforms the traditional approach in space and time.</p>
  </div>
  <footer class="entry-footer"><span title='2023-09-24 00:00:00 +0000 UTC'>September 2023</span>&nbsp;&middot;&nbsp;Francesco Fabiano,&thinsp;Alessandro Burigana,&thinsp;Agostino Dovier,&thinsp;Enrico Pontelli</footer>
  <a class="entry-link" aria-label="post link to DELPHIC: Practical DEL Planning via Possibilities" href="http://localhost:1313/papers/2023-09-24-jelia/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">The Epistemic Planning Domain Definition Language (Short Paper)
    </h2>
  </header>
  <div class="entry-content">
    <p>Epistemic planning is a branch of Artificial Intelligence that stems from the combination of automated planning and Dynamic Epistemic Logic (DEL). While DEL provides a very expressive framework—which comes at the cost of undecidability—to guarantee the feasibility of the planning process, various fragments have been studied in the literature, that rely on very specific syntax for representing domains. As a result, a comprehensive language that is able to capture the general DEL framework is currently not present in the literature. In this paper, we propose a new language called EPDDL (Epistemic Planning Domain Definition Language), through which we can capture the full DEL semantics, thus allowing for a general and unified syntax for representing epistemic planning domains.</p>
  </div>
  <footer class="entry-footer"><span title='2022-11-29 00:00:00 +0000 UTC'>November 2022</span>&nbsp;&middot;&nbsp;Alessandro Burigana,&thinsp;Francesco Fabiano</footer>
  <a class="entry-link" aria-label="post link to The Epistemic Planning Domain Definition Language (Short Paper)" href="http://localhost:1313/papers/2022-11-29-ips/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">DELPHIC: Towards an Efficient Possibility-based Epistemic Planning Framework
    </h2>
  </header>
  <div class="entry-content">
    <p>Dynamic Epistemic Logic (DEL) provides a very expressive framework for planning, called epistemic planning. In this paper, we discuss the shortcomings of the traditional DEL semantics, based on Kripke models, and we propose a formulation of epistemic planning based on a different kind of object, called possibility. We argue that the resulting framework, named DELPHIC, constitutes a valid alternative, since it provides a more compact representation of epistemic information and a lighter update mechanism. We conclude by discussing the advantages of DELPHIC, both theoretically and in terms of implementation.</p>
  </div>
  <footer class="entry-footer"><span title='2022-11-28 00:00:00 +0000 UTC'>November 2022</span>&nbsp;&middot;&nbsp;Alessandro Burigana,&thinsp;Paolo Felli,&thinsp;Marco Montali</footer>
  <a class="entry-link" aria-label="post link to DELPHIC: Towards an Efficient Possibility-based Epistemic Planning Framework" href="http://localhost:1313/papers/2022-11-28-overlay/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Multi-Agent Epistemic Planning with Inconsistent Beliefs, Trust and Lies
    </h2>
  </header>
  <div class="entry-content">
    <p>Developing autonomous agents that can reason about the perspective of their (human or artificial) peers is paramount to realistically model a variety of real-world domains. Being aware of the state of mind of others is a key aspect in different fields—e.g., legal reasoning, business negotiations, ethical AI and explainable AI. In particular, in the area of Multi-Agent Epistemic Planning (MEP), agents must reach their goals by taking into account the knowledge and beliefs of other agents. Although the literature offers an ample spectrum of approaches for planning in this scenario, they often come with limitations. This paper expands previous formalization of MEP to enable representing and reasoning in presence of inconsistent beliefs of agents, trust relations and lies. The paper explores the syntax and semantics of the extended MEP framework, along with an implementation of the framework in the solver Epistemic Forward Planner (EFP). The paper reports formal properties about the newly introduced epistemic states update that have been also empirically tested via an actual implementation of the solver.</p>
  </div>
  <footer class="entry-footer"><span title='2021-10-25 00:00:00 +0000 UTC'>October 2021</span>&nbsp;&middot;&nbsp;Francesco Fabiano,&thinsp;Alessandro Burigana,&thinsp;Agostino Dovier,&thinsp;Enrico Pontelli,&thinsp;Tran Cao Son</footer>
  <a class="entry-link" aria-label="post link to Multi-Agent Epistemic Planning with Inconsistent Beliefs, Trust and Lies" href="http://localhost:1313/papers/2021-10-25-pricai/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Modelling Multi-Agent Epistemic Planning in ASP
    </h2>
  </header>
  <div class="entry-content">
    <p>Designing agents that reason and act upon the world has always been one of the main objectives of the Artificial Intelligence community. While for planning in “simple” domains the agents can solely rely on facts about the world, in several contexts, e.g., economy, security, justice and politics, the mere knowledge of the world could be insufficient to reach a desired goal. In these scenarios, epistemic reasoning, i.e., reasoning about agents’ beliefs about themselves and about other agents’ beliefs, is essential to design winning strategies. This paper addresses the problem of reasoning in multi-agent epistemic settings exploiting declarative programming techniques. In particular, the paper presents an actual implementation of a multi-shot Answer Set Programming-based planner that can reason in multi-agent epistemic settings, called PLATO (ePistemic muLti-agent Answer seT programming sOlver). The ASP paradigm enables a concise and elegant design of the planner, w.r.t. other imperative implementations, facilitating the development of formal verification of correctness. The paper shows how the planner, exploiting an ad-hoc epistemic state representation and the efficiency of ASP solvers, has competitive performance results on benchmarks collected from the literature.</p>
  </div>
  <footer class="entry-footer"><span title='2020-09-21 00:00:00 +0000 UTC'>September 2020</span>&nbsp;&middot;&nbsp;Alessandro Burigana,&thinsp;Francesco Fabiano,&thinsp;Agostino Dovier,&thinsp;Enrico Pontelli</footer>
  <a class="entry-link" aria-label="post link to Modelling Multi-Agent Epistemic Planning in ASP" href="http://localhost:1313/papers/2020-09-21-tplp/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">EFP 2.0: A Multi-Agent Epistemic Solver with Multiple E-State Representations
    </h2>
  </header>
  <div class="entry-content">
    <p>Multi-agent systems have been employed to model, simulate and explore a variety of real-world scenarios. It is becoming more and more important to investigate formalisms and tools that would allow us to exploit automated reasoning in these domains. An area that has received increasing attention is the use of multi-agent systems which allow an agent to reason about the knowledge and beliefs of other agents. This type of reasoning, i.e., about agents’ perception of the world and also about agents’ knowledge of her and others’ knowledge, is referred to as epistemic reasoning. This paper presents an updated formalization and implementation of a multi-agent epistemic planner, called EFP. In particular, the paper explores the advantages of using alternative state representations that deviate from the commonly used Kripke structures. The paper explores such alternatives in the context of an action language for multi-agent epistemic planning. The paper presents also an actual implementation of a planner that uses the novel ideas, demonstrating concrete performance improvements on benchmarks collected from the literature.</p>
  </div>
  <footer class="entry-footer"><span title='2020-06-01 00:00:00 +0000 UTC'>June 2020</span>&nbsp;&middot;&nbsp;Francesco Fabiano,&thinsp;Alessandro Burigana,&thinsp;Agostino Dovier,&thinsp;Enrico Pontelli</footer>
  <a class="entry-link" aria-label="post link to EFP 2.0: A Multi-Agent Epistemic Solver with Multiple E-State Representations" href="http://localhost:1313/papers/2020-06-01-icaps/"></a>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2025 <a href="http://localhost:1313/">Alessandro Burigana</a></span> ·     
    <span>
    Powered by 
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/pmichaillat/hugo-website/" rel="noopener" target="_blank">a modified version</a>
         of 
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
</body>
</html>
